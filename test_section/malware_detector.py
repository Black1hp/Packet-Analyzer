#!/usr/bin/env python3
"""
Mitmproxy script to detect potentially malicious file downloads.

This script monitors HTTP/HTTPS traffic, detects downloads of potentially
malicious files, calculates their SHA256 hash, and checks them against
the VirusTotal API.

Usage:
    mitmproxy -s malware_detector.py

Requirements:
    - mitmproxy
    - requests
    - hashlib (standard library)
    - time (standard library)
    - os (standard library)
    - json (standard library)
    - urllib.parse (standard library)
"""

import os
import hashlib
import time
import json
import requests
import urllib.parse
from mitmproxy import http
from malicious_file_types import is_potentially_malicious

# Configuration
# Load API key from environment variable instead of hardcoding
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

VIRUSTOTAL_API_KEY = os.getenv("VIRUSTOTAL_API_KEY", "")
HASHES_FILE = "hashes.txt"
RESULTS_FILE = "vt_results.txt"
RATE_LIMIT_DELAY = 1  # seconds between VirusTotal API requests

# Global variables
last_api_call_time = 0

def extract_filename_from_headers(flow):
    """
    Extract filename from Content-Disposition header or URL path.
    
    Args:
        flow: The mitmproxy flow object
        
    Returns:
        str: The extracted filename or None if not found
    """
    # Try to get filename from Content-Disposition header
    content_disposition = flow.response.headers.get("Content-Disposition", "")
    if "filename=" in content_disposition:
        # Extract filename from the header
        filename_part = content_disposition.split("filename=")[1]
        if '"' in filename_part:
            filename = filename_part.split('"')[1]
        else:
            filename = filename_part.split(';')[0].strip()
        return filename
    
    # If no Content-Disposition header, try to extract from URL path
    path = urllib.parse.urlparse(flow.request.url).path
    if path and '/' in path:
        return path.split('/')[-1]
    
    return None

def calculate_sha256(data):
    """
    Calculate SHA256 hash of binary data.
    
    Args:
        data (bytes): Binary data to hash
        
    Returns:
        str: SHA256 hash as a hexadecimal string
    """
    return hashlib.sha256(data).hexdigest()

def log_hash(file_hash, url):
    """
    Log a hash to the hashes file.
    
    Args:
        file_hash (str): The SHA256 hash to log
        url (str): The URL where the file was downloaded from
    """
    with open(HASHES_FILE, 'a') as f:
        f.write(f"{file_hash} {url}\n")

def query_virustotal(file_hash):
    """
    Query the VirusTotal API for a file hash.
    
    Args:
        file_hash (str): The SHA256 hash to query
        
    Returns:
        dict: The VirusTotal API response or None if the request failed
    """
    global last_api_call_time
    
    # Respect rate limit
    current_time = time.time()
    time_since_last_call = current_time - last_api_call_time
    if time_since_last_call < RATE_LIMIT_DELAY:
        time.sleep(RATE_LIMIT_DELAY - time_since_last_call)
    
    # Update last call time
    last_api_call_time = time.time()
    
    # Make API request
    url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
    headers = {
        "x-apikey": VIRUSTOTAL_API_KEY
    }
    
    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            return response.json()
        elif response.status_code == 404:
            # File not found in VirusTotal database
            return {"data": {"attributes": {"last_analysis_stats": {"malicious": 0, "suspicious": 0, "undetected": 0}}}}
        else:
            print(f"VirusTotal API error: {response.status_code} - {response.text}")
            return None
    except Exception as e:
        print(f"Error querying VirusTotal: {e}")
        return None

def log_virustotal_result(file_hash, result, url):
    """
    Log VirusTotal scan results to the results file.
    
    Args:
        file_hash (str): The SHA256 hash that was scanned
        result (dict): The VirusTotal API response
        url (str): The URL where the file was downloaded from
    """
    try:
        # Extract relevant information from the result
        if result and "data" in result:
            stats = result["data"]["attributes"]["last_analysis_stats"]
            malicious = stats.get("malicious", 0)
            suspicious = stats.get("suspicious", 0)
            undetected = stats.get("undetected", 0)
            total = malicious + suspicious + undetected
            
            # Determine verdict
            if malicious > 0:
                verdict = "MALICIOUS"
            elif suspicious > 0:
                verdict = "SUSPICIOUS"
            else:
                verdict = "CLEAN"
            
            # Log the result
            with open(RESULTS_FILE, 'a') as f:
                f.write(f"Hash: {file_hash}\n")
                f.write(f"URL: {url}\n")
                f.write(f"Verdict: {verdict}\n")
                f.write(f"Stats: {malicious}/{total} engines detected as malicious\n")
                f.write(f"Details: {malicious} malicious, {suspicious} suspicious, {undetected} undetected\n")
                f.write("-" * 80 + "\n")
        else:
            # Log error if result is invalid
            with open(RESULTS_FILE, 'a') as f:
                f.write(f"Hash: {file_hash}\n")
                f.write(f"URL: {url}\n")
                f.write(f"Verdict: ERROR\n")
                f.write(f"Details: Failed to get valid response from VirusTotal\n")
                f.write("-" * 80 + "\n")
    except Exception as e:
        print(f"Error logging VirusTotal result: {e}")

def response(flow):
    """
    Mitmproxy response hook to process HTTP/HTTPS responses.
    
    This function is called by mitmproxy for each HTTP/HTTPS response.
    It checks if the response contains a potentially malicious file,
    calculates its SHA256 hash, and queries the VirusTotal API.
    
    Args:
        flow: The mitmproxy flow object
    """
    try:
        # Skip responses without content
        if not flow.response or not flow.response.content:
            return
        
        # Extract filename from headers or URL
        filename = extract_filename_from_headers(flow)
        if not filename:
            return
        
        # Check if the file is potentially malicious
        if not is_potentially_malicious(filename):
            return
        
        # Calculate SHA256 hash
        file_hash = calculate_sha256(flow.response.content)
        
        # Log the hash
        log_hash(file_hash, flow.request.url)
        
        # Query VirusTotal API
        vt_result = query_virustotal(file_hash)
        
        # Log VirusTotal result
        log_virustotal_result(file_hash, vt_result, flow.request.url)
        
        # Print information to console
        print(f"[+] Detected potential malware: {filename}")
        print(f"    URL: {flow.request.url}")
        print(f"    SHA256: {file_hash}")
        if vt_result and "data" in vt_result:
            stats = vt_result["data"]["attributes"]["last_analysis_stats"]
            malicious = stats.get("malicious", 0)
            total = sum(stats.values())
            print(f"    VirusTotal: {malicious}/{total} detections")
        print()
        
    except Exception as e:
        print(f"Error in response hook: {e}")

# Initialize log files if they don't exist
def initialize_log_files():
    """Initialize log files with headers if they don't exist."""
    if not os.path.exists(HASHES_FILE):
        with open(HASHES_FILE, 'w') as f:
            f.write("# SHA256 hashes of potentially malicious files\n")
            f.write("# Format: <hash> <url>\n")
    
    if not os.path.exists(RESULTS_FILE):
        with open(RESULTS_FILE, 'w') as f:
            f.write("# VirusTotal scan results for potentially malicious files\n")
            f.write("# " + "-" * 78 + "\n")

# Initialize log files when the script is loaded
initialize_log_files()

print("[*] Malware detector script loaded")
print("[*] Monitoring for potentially malicious file downloads...")
print("[*] Results will be saved to:")
print(f"    - {HASHES_FILE}")
print(f"    - {RESULTS_FILE}")
