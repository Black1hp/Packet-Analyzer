#!/usr/bin/env python3
"""
Malware Detection Module for Network Forensics

This module monitors HTTP/HTTPS traffic, detects downloads of potentially
malicious files, calculates their SHA256 hash, and checks them against
the VirusTotal API.

It integrates with the Network Forensics project to provide real-time
malware detection capabilities.
"""

import os
import hashlib
import time
import json
import requests
import urllib.parse
import logging
from datetime import datetime
from collections import defaultdict
import threading
from .malicious_file_types import is_potentially_malicious

# Configure logger
logger = logging.getLogger(__name__)
if not logger.handlers:
    logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(module)s - %(message)s")

# Configuration (will be loaded from .env)
VIRUSTOTAL_API_KEY = os.getenv("VIRUSTOTAL_API_KEY", "")
HASHES_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "hashes.txt")
RESULTS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "vt_results.txt")
RATE_LIMIT_DELAY = 15  # seconds between VirusTotal API requests (free tier limit)
ALERT_COOLDOWN_MINUTES = 5  # minutes between alerts for the same file

# Global variables
last_api_call_time = 0
processed_files = {}  # To track processed files and avoid duplicates

class MalwareDetector:
    def __init__(self):
        """Initialize the malware detector."""
        self.initialize_log_files()
        logger.info("Malware detector initialized")
        
    def initialize_log_files(self):
        """Initialize log files with headers if they don't exist."""
        if not os.path.exists(HASHES_FILE):
            with open(HASHES_FILE, 'w') as f:
                f.write("# SHA256 hashes of potentially malicious files\n")
                f.write("# Format: <hash> <url>\n")
        
        if not os.path.exists(RESULTS_FILE):
            with open(RESULTS_FILE, 'w') as f:
                f.write("# VirusTotal scan results for potentially malicious files\n")
                f.write("# " + "-" * 78 + "\n")

    def extract_filename_from_headers(self, headers, url):
        """
        Extract filename from Content-Disposition header or URL path.
        
        Args:
            headers (dict): HTTP headers
            url (str): The URL where the file was downloaded from
            
        Returns:
            str: The extracted filename or None if not found
        """
        # Try to get filename from Content-Disposition header
        content_disposition = headers.get("Content-Disposition", "")
        if "filename=" in content_disposition:
            # Extract filename from the header
            filename_part = content_disposition.split("filename=")[1]
            if '"' in filename_part:
                filename = filename_part.split('"')[1]
            else:
                filename = filename_part.split(';')[0].strip()
            return filename
        
        # If no Content-Disposition header, try to extract from URL path
        path = urllib.parse.urlparse(url).path
        if path and '/' in path:
            return path.split('/')[-1]
        
        return None

    def calculate_sha256(self, data):
        """
        Calculate SHA256 hash of binary data.
        
        Args:
            data (bytes): Binary data to hash
            
        Returns:
            str: SHA256 hash as a hexadecimal string
        """
        return hashlib.sha256(data).hexdigest()

    def log_hash(self, file_hash, url):
        """
        Log a hash to the hashes file.
        
        Args:
            file_hash (str): The SHA256 hash to log
            url (str): The URL where the file was downloaded from
        """
        with open(HASHES_FILE, 'a') as f:
            f.write(f"{file_hash} {url}\n")

    def query_virustotal(self, file_hash):
        """
        Query the VirusTotal API for a file hash.
        
        Args:
            file_hash (str): The SHA256 hash to query
            
        Returns:
            dict: The VirusTotal API response or None if the request failed
        """
        global last_api_call_time
        
        # Check if API key is configured
        if not VIRUSTOTAL_API_KEY:
            logger.warning("VirusTotal API key not configured. Skipping scan.")
            return None
        
        # Respect rate limit
        current_time = time.time()
        time_since_last_call = current_time - last_api_call_time
        if time_since_last_call < RATE_LIMIT_DELAY:
            time.sleep(RATE_LIMIT_DELAY - time_since_last_call)
        
        # Update last call time
        last_api_call_time = time.time()
        
        # Make API request
        url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
        headers = {
            "x-apikey": VIRUSTOTAL_API_KEY
        }
        
        try:
            response = requests.get(url, headers=headers)
            if response.status_code == 200:
                return response.json()
            elif response.status_code == 404:
                # File not found in VirusTotal database
                return {"data": {"attributes": {"last_analysis_stats": {"malicious": 0, "suspicious": 0, "undetected": 0}}}}
            else:
                logger.error(f"VirusTotal API error: {response.status_code} - {response.text}")
                return None
        except Exception as e:
            logger.error(f"Error querying VirusTotal: {e}")
            return None

    def log_virustotal_result(self, file_hash, result, url):
        """
        Log VirusTotal scan results to the results file.
        
        Args:
            file_hash (str): The SHA256 hash that was scanned
            result (dict): The VirusTotal API response
            url (str): The URL where the file was downloaded from
        """
        try:
            # Extract relevant information from the result
            if result and "data" in result:
                stats = result["data"]["attributes"]["last_analysis_stats"]
                malicious = stats.get("malicious", 0)
                suspicious = stats.get("suspicious", 0)
                undetected = stats.get("undetected", 0)
                total = malicious + suspicious + undetected
                
                # Determine verdict
                if malicious > 0:
                    verdict = "MALICIOUS"
                elif suspicious > 0:
                    verdict = "SUSPICIOUS"
                else:
                    verdict = "CLEAN"
                
                # Log the result
                with open(RESULTS_FILE, 'a') as f:
                    f.write(f"Hash: {file_hash}\n")
                    f.write(f"URL: {url}\n")
                    f.write(f"Verdict: {verdict}\n")
                    f.write(f"Stats: {malicious}/{total} engines detected as malicious\n")
                    f.write(f"Details: {malicious} malicious, {suspicious} suspicious, {undetected} undetected\n")
                    f.write("-" * 80 + "\n")
                
                return {
                    "hash": file_hash,
                    "url": url,
                    "verdict": verdict,
                    "malicious": malicious,
                    "suspicious": suspicious,
                    "undetected": undetected,
                    "total": total
                }
            else:
                # Log error if result is invalid
                with open(RESULTS_FILE, 'a') as f:
                    f.write(f"Hash: {file_hash}\n")
                    f.write(f"URL: {url}\n")
                    f.write(f"Verdict: ERROR\n")
                    f.write(f"Details: Failed to get valid response from VirusTotal\n")
                    f.write("-" * 80 + "\n")
                
                return {
                    "hash": file_hash,
                    "url": url,
                    "verdict": "ERROR",
                    "error": "Failed to get valid response from VirusTotal"
                }
        except Exception as e:
            logger.error(f"Error logging VirusTotal result: {e}")
            return None

    def format_file_size(self, size_in_bytes):
        """
        Format a file size from bytes to a human-readable string.
        
        Args:
            size_in_bytes (int): File size in bytes
            
        Returns:
            str: Human-readable file size
        """
        if size_in_bytes < 1024:
            return f"{size_in_bytes} bytes"
        elif size_in_bytes < 1024 * 1024:
            return f"{size_in_bytes / 1024:.2f} KB"
        elif size_in_bytes < 1024 * 1024 * 1024:
            return f"{size_in_bytes / (1024 * 1024):.2f} MB"
        else:
            return f"{size_in_bytes / (1024 * 1024 * 1024):.2f} GB"

    def process_http_response(self, event_data):
        """
        Process HTTP response data from Suricata to detect potential malware.
        
        Args:
            event_data (dict): Suricata event data
            
        Returns:
            dict: Detection result if malware detected, None otherwise
        """
        try:
            # Check if this is an HTTP event with response body
            if not event_data.get('event_type') == 'http':
                return None
                
            http_data = event_data.get('http', {})
            
            # Skip responses without content
            if not http_data or 'http_body' not in http_data:
                return None
            
            # Extract HTTP body content
            content = http_data.get('http_body')
            if not content:
                return None
            
            # Convert content to bytes if it's a string
            if isinstance(content, str):
                content = content.encode('utf-8')
            
            # Extract URL
            url = http_data.get('url', '')
            if not url:
                url = f"{http_data.get('hostname', '')}:{http_data.get('http_port', '')}"
            
            # Extract headers
            headers = http_data.get('http_response_headers', {})
            
            # Extract filename from headers or URL
            filename = self.extract_filename_from_headers(headers, url)
            if not filename:
                return None
            
            # Check if the file is potentially malicious
            if not is_potentially_malicious(filename):
                return None
            
            # Calculate SHA256 hash
            file_hash = self.calculate_sha256(content)
            
            # Check if we've already processed this file recently
            file_key = f"{file_hash}_{url}"
            if file_key in processed_files:
                last_processed_time = processed_files[file_key]
                time_diff = (datetime.now() - last_processed_time).total_seconds() / 60
                if time_diff < ALERT_COOLDOWN_MINUTES:
                    return None
            
            # Update processed files
            processed_files[file_key] = datetime.now()
            
            # Log the hash
            self.log_hash(file_hash, url)
            
            # Query VirusTotal API
            vt_result = self.query_virustotal(file_hash)
            
            # Log VirusTotal result
            result_data = self.log_virustotal_result(file_hash, vt_result, url)
            
            # Prepare detection result
            if result_data:
                # Get the current timestamp
                current_time = datetime.now().isoformat()
                
                # Determine verdict based on VirusTotal results
                verdict = "ERROR"
                detection_ratio = "0/0"
                if vt_result and "data" in vt_result:
                    stats = vt_result["data"]["attributes"]["last_analysis_stats"]
                    malicious = stats.get("malicious", 0)
                    suspicious = stats.get("suspicious", 0)
                    total = sum(stats.values())
                    detection_ratio = f"{malicious}/{total}"
                    
                    # Determine verdict based on detection ratio
                    if malicious > 5:
                        verdict = "MALICIOUS"
                    elif malicious > 0 or suspicious > 2:
                        verdict = "SUSPICIOUS"
                    elif total > 0:
                        verdict = "CLEAN"
                
                # Create detailed information about the detection
                file_size = len(content) if content else 0
                file_size_formatted = self.format_file_size(file_size)
                
                # Content type
                content_type = headers.get("Content-Type", "Unknown")
                
                # Prepare detailed detection result
                detection_result = {
                    'type': 'malware_detection',
                    'timestamp': current_time,
                    'filename': filename,
                    'url': url,
                    'hash': file_hash,
                    'result': result_data,
                    'verdict': verdict,
                    'detection_ratio': detection_ratio,
                    'file_size': file_size_formatted,
                    'content_type': content_type,
                    'details': f"Potentially malicious file detected: {filename}\nVerdict: {verdict}\nDetection ratio: {detection_ratio}"
                }
                
                # Log detection
                logger.info(f"[+] Detected potential malware: {filename}")
                logger.info(f"    URL: {url}")
                logger.info(f"    SHA256: {file_hash}")
                logger.info(f"    Verdict: {verdict}")
                
                if vt_result and "data" in vt_result:
                    stats = vt_result["data"]["attributes"]["last_analysis_stats"]
                    malicious = stats.get("malicious", 0)
                    total = sum(stats.values())
                    logger.info(f"    VirusTotal: {malicious}/{total} detections")
                
                # Send email alert
                try:
                    from backend.server import send_email_alert
                    alert_subject = f"Malware Detection: {filename}"
                    alert_data = {
                        'type': 'malware_detection',
                        'filename': filename,
                        'url': url,
                        'hash': file_hash,
                        'verdict': verdict,
                        'detection_ratio': detection_ratio,
                        'file_size': file_size_formatted,
                        'content_type': content_type,
                        'timestamp': current_time,
                        'details': f"Potentially malicious file detected: {filename}\nVerdict: {verdict}\nDetection ratio: {detection_ratio}",
                        'source_ip': event_data.get("src_ip", "Unknown"),
                        'destination_ip': event_data.get("dest_ip", "Unknown"),
                        'sourceIP': event_data.get("src_ip", "Unknown"),
                        'destinationIP': event_data.get("dest_ip", "Unknown"),
                        'protocol': event_data.get("proto", "HTTP/HTTPS")
                    }
                    send_email_alert(alert_subject, alert_data, alert_type_for_email_subject="Malware Detection")
                    logger.info(f"Sent email alert for malware detection: {filename}")
                except Exception as e:
                    logger.error(f"Failed to send email alert for malware detection: {e}")
                
                return detection_result
            
        except Exception as e:
            logger.error(f"Error in process_http_response: {e}")
        
        return None

    def process_suricata_event(self, event_data):
        """
        Process a Suricata event to detect potential malware.
        
        Args:
            event_data (dict): Suricata event data
            
        Returns:
            dict: Detection result if malware detected, None otherwise
        """
        # Process HTTP response
        return self.process_http_response(event_data)


# Create a global instance of the detector
malware_detector = MalwareDetector()

def process_suricata_event(event_data):
    """
    Process a Suricata event to detect potential malware.
    This function is called by the server.py module.
    
    Args:
        event_data (dict): Suricata event data
        
    Returns:
        dict: Detection result if malware detected, None otherwise
    """
    global malware_detector
    return malware_detector.process_suricata_event(event_data)
